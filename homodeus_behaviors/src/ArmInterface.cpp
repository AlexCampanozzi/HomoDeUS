#include <homodeus_arm_interface/ArmInterface.h>


/* ArmInterface: Constructor

Description:    Initialize various parameters to communicate
                with the arm and the torso through MoveIt.

Inputs:         None

Outputs:        None
*/
void openGripper(trajectory_msgs::JointTrajectory& posture)
{
    // BEGIN_SUB_TUTORIAL open_gripper
    /* Add both finger joints of panda robot. */
    posture.joint_names.resize(3);
    posture.joint_names[0] = "hand_index_joint";
    posture.joint_names[1] = "hand_mrl_joint";
    posture.joint_names[2] = "hand_thumb_joint";

    /* Set them as open, wide enough for the object to fit. */
    posture.points.resize(1);
    posture.points[0].positions.resize(3);
    posture.points[0].positions[0] = 0;
    posture.points[0].positions[1] = 0;
    posture.points[0].positions[2] = 0;
    posture.points[0].time_from_start = ros::Duration(1);
    // END_SUB_TUTORIAL
}

void closedGripper(trajectory_msgs::JointTrajectory& posture)
{
    // BEGIN_SUB_TUTORIAL closed_gripper
    /* Add both finger joints of panda robot. */
    posture.joint_names.resize(3);
    posture.joint_names[0] = "hand_index_joint";
    posture.joint_names[1] = "hand_mrl_joint";
    posture.joint_names[2] = "hand_thumb_joint";

    /* Set them as closed. */
    posture.points.resize(1);
    posture.points[0].positions.resize(3);
    posture.points[0].positions[0] = 0.80;
    posture.points[0].positions[1] = 1.60;
    posture.points[0].positions[2] = 0.85;
    posture.points[0].time_from_start = ros::Duration(1);
    // END_SUB_TUTORIAL
}

ArmInterface::ArmInterface() : _moveGroup("arm_torso"), _ref_frame("base_link")
{
    // Using 5 seconds because it's a reasonable delay
    _planningTime = 5.0;
    _plannerId = "SBLkConfigDefault";

    _moveGroup.setPlannerId(_plannerId);

    _jointsNames = _moveGroup.getJoints();

    // Using a factor of 1.0 at first, we'll see if this value needs to be changed
    _moveGroup.setMaxVelocityScalingFactor(1.0);
}

/* ArmInterface: Alternative Constructor

Description:    Initialize various parameters to communicate
                with the arm and the torso through MoveIt,
                specifying which tf frame to use for cartesian.

Inputs:         ref_frame (type, std::string)
                    The tf frame in which points are to be taken for cartesian movement

Outputs:        None
*/
ArmInterface::ArmInterface(std::string ref_frame) : _moveGroup("arm_torso"), _ref_frame(ref_frame)
{
    // Using 5 seconds because it's a reasonable delay
    _planningTime = 5.0;
    _plannerId = "SBLkConfigDefault";

    _moveGroup.setPlannerId(_plannerId);

    _jointsNames = _moveGroup.getJoints();

    // Using a factor of 1.0 at first, we'll see if this value needs to be changed
    _moveGroup.setMaxVelocityScalingFactor(1.0);
}

/* ArmInterface: Trajectory Planner in Cartesian Space

Description:    This method uses MoveIt to plan a trajectory
                in cartesian space according to a target.

Inputs:         None

Outputs:        plan (type, moveit::planning_interface::MoveGroupInterface::Plan):
                    Reference to the plan generated by MoveIt.

                success (type, bool):
                    This method returns true if the planner was able to find a trajectory
                    and false otherwise.
*/
bool ArmInterface::planTrajectory(moveit::planning_interface::MoveGroupInterface::Plan &plan)
{
    _moveGroup.setStartStateToCurrentState();
    _moveGroup.setPlanningTime(_planningTime);

    auto success = _moveGroup.plan(plan);

    return bool(success);
}


/* ArmInterface: Trajectory Planner in Joints Space

Description:    This method uses MoveIt to plan a trajectory
                in joints space according to a target.

Inputs:         None

Outputs:        plan (type, moveit::planning_interface::MoveGroupInterface::Plan):
                    Reference to the plan generated by MoveIt.

                success (type, bool):
                    This method returns true if the planner was able to find a trajectory
                    and false otherwise.
*/
bool ArmInterface::planTrajectoryJ(moveit::planning_interface::MoveGroupInterface::Plan &plan)
{
    _moveGroup.setStartStateToCurrentState();
    _moveGroup.setPlanningTime(_planningTime);

    bool success = static_cast<bool>(_moveGroup.plan(plan));

    return success;
}


/* ArmInterface: Set Planning Time

Description:    This method sets the time allowed to the planner to find
                a trajectory. The default value of the planning time is
                5.0 seconds.

Inputs:         value (type: float)
                    The new value for the planning time.

Outputs:        None
*/
void ArmInterface::setPlanningTime(float value)
{
    _planningTime = value;
}


/* ArmInterface: Set the Planner ID

Description:    This method sets the planner's name used by MoveIt to find
                a trajectory. The default value of the planner's ID is set
                to "SBLkConfigDefault".

Inputs:         Id (type, std::string):
                    The new planner's ID

Outputs:        None
*/
void ArmInterface::setPlannerId(std::string id)
{
    _plannerId = id;
    _moveGroup.setPlannerId(_plannerId);
}


/* ArmInterface: Move the Arm To a Desired Position in Cartesian Space

Description:    This method uses the planTrajectory() method to find a trajectory
                to a desired position in cartesian space and moves the arm if a
                plan is found.

Inputs:         x (type, double):
                    The X coordinate of the desired position.

                y (type, double):
                    The Y coordinate of the desired position.

                z (type, double):
                    The Z coordinate of the desired position.

                roll (type, double):
                    The roll of the desired position.

                pitch (type, double):
                    The pitch of the desired position.

                yaw (type, double):
                    The yaw of the desired position.

Outputs:        success (type, bool):
                    This method returns true if it was able to move the arm and
                    false otherwise.
*/
bool ArmInterface::moveToCartesian(double x, double y, double z, double roll, double pitch, double yaw)
{
    geometry_msgs::PoseStamped goalPose;
    goalPose.header.frame_id = _ref_frame;
    goalPose.pose.position.x = x;
    goalPose.pose.position.y = y;
    goalPose.pose.position.z = z;
    goalPose.pose.orientation = tf::createQuaternionMsgFromRollPitchYaw(roll, pitch, yaw);

    _moveGroup.setPoseReferenceFrame(_ref_frame);
    ROS_INFO("ArmInterface::moveToCartesian(): Frame set");
    _moveGroup.setPoseTarget(goalPose);
    ROS_INFO("ArmInterface::moveToCartesian(): Target pose set");

    moveit::planning_interface::MoveGroupInterface::Plan cartesianPlan;
    ROS_INFO("ArmInterface::moveToCartesian(): Plan created");
    bool success = planTrajectory(cartesianPlan);
    ROS_INFO("ArmInterface::moveToCartesian(): Plan computed");

    if (!success)
    {
        ROS_INFO("ArmInterface::moveTo(): No plan found!");
        return false;
    }
    else
    {
        ROS_INFO("ArmInterface::moveTo(): Plan found!");
    }

    _moveGroup.move();

    return true;
}


/* ArmInterface: Move the Arm To a Desired Position in Joints Space

Description:    This method uses the planTrajectoryJ() method to find a trajectory
                to a desired position in joints space and moves the arm if a
                plan is found.

Inputs:         torso (type, double):
                    The desired position of the torso.

                j1 (type, double):
                    The desired position of the first joint of the arm.

                j2 (type, double):
                    The desired position of the second joint of the arm.

                j3 (type, double):
                    The desired position of the third joint of the arm.

                j4 (type, double):
                    The desired position of the fourth joint of the arm.

                j5 (type, double):
                    The desired position of the fifth joint of the arm.

                j6 (type, double):
                    The desired position of the sixth joint of the arm.

                j7 (type, double):
                    The desired position of the seventh joint of the arm.

Outputs:        success (type, bool):
                    This method returns true if it was able to move the arm and
                    false otherwise.
*/
bool ArmInterface::moveToJoint(double torso, double j1, double j2, double j3, double j4, double j5, double j6, double j7)
{
    std::map<std::string, double> targetPosition;

    targetPosition["torso_lift_joint"] = torso;
    targetPosition["arm_1_joint"] = j1;
    targetPosition["arm_2_joint"] = j2;
    targetPosition["arm_3_joint"] = j3;
    targetPosition["arm_4_joint"] = j4;
    targetPosition["arm_5_joint"] = j5;
    targetPosition["arm_6_joint"] = j6;
    targetPosition["arm_7_joint"] = j7;

    for (unsigned int i = 0; i < _jointsNames.size(); i++)
    {
        if (targetPosition.count(_jointsNames[i]) > 0)
            _moveGroup.setJointValueTarget(_jointsNames[i], targetPosition[_jointsNames[i]]);
    }

    moveit::planning_interface::MoveGroupInterface::Plan jointsPlan;
    bool success = planTrajectoryJ(jointsPlan);

    if (!success)
    {
        ROS_INFO("ArmInterface::moveToJ(): No plan found!");
        return false;
    }

    _moveGroup.move();

    return true;
}

bool ArmInterface::pick(geometry_msgs::PoseStamped object_pose)
{
  // BEGIN_SUB_TUTORIAL pick1
  // Create a vector of grasps to be attempted, currently only creating single grasp.
  // This is essentially useful when using a grasp generator to generate and test multiple grasps.
  std::vector<moveit_msgs::Grasp> grasps;
  grasps.resize(1);

  // Setting grasp pose
  // ++++++++++++++++++++++
  // This is the pose of panda_link8. |br|
  // From panda_link8 to the palm of the eef the distance is 0.058, the cube starts 0.01 before 5.0 (half of the length
  // of the cube). |br|
  // Therefore, the position for panda_link8 = 5 - (length of cube/2 - distance b/w panda_link8 and palm of eef - some
  // extra padding)
  grasps[0].grasp_pose.header.frame_id = object_pose.header.frame_id;
  grasps[0].grasp_pose.pose.orientation = object_pose.pose.orientation;
  grasps[0].grasp_pose.pose.position.x = object_pose.pose.position.x - 0.1;
  grasps[0].grasp_pose.pose.position.y = object_pose.pose.position.y - 0.05;
  grasps[0].grasp_pose.pose.position.z = object_pose.pose.position.z;

  // Setting pre-grasp approach
  // ++++++++++++++++++++++++++
  /* Defined with respect to frame_id */
  grasps[0].pre_grasp_approach.direction.header.frame_id = _ref_frame;
  /* Direction is set as positive x axis */
  grasps[0].pre_grasp_approach.direction.vector.x = 1.0;
  grasps[0].pre_grasp_approach.min_distance = 0.095;
  grasps[0].pre_grasp_approach.desired_distance = 0.115;

  // Setting post-grasp retreat
  // ++++++++++++++++++++++++++
  /* Defined with respect to frame_id */
  grasps[0].post_grasp_retreat.direction.header.frame_id = _ref_frame;
  /* Direction is set as positive z axis */
  grasps[0].post_grasp_retreat.direction.vector.z = 1.0;
  grasps[0].post_grasp_retreat.min_distance = 0.1;
  grasps[0].post_grasp_retreat.desired_distance = 0.25;

  // Setting posture of eef before grasp
  // +++++++++++++++++++++++++++++++++++
  openGripper(grasps[0].pre_grasp_posture);
  // END_SUB_TUTORIAL

  // BEGIN_SUB_TUTORIAL pick2
  // Setting posture of eef during grasp
  // +++++++++++++++++++++++++++++++++++
  closedGripper(grasps[0].grasp_posture);
  // END_SUB_TUTORIAL

  // BEGIN_SUB_TUTORIAL pick3
  // Set support surface as table1.
  _moveGroup.setSupportSurfaceName("table1");
  // Call pick to pick up the object using the grasps given
  return bool(_moveGroup.pick("object", grasps));
  // END_SUB_TUTORIAL
}

bool ArmInterface::place(geometry_msgs::PoseStamped drop_pose)
{
  // BEGIN_SUB_TUTORIAL place
  // TODO(@ridhwanluthra) - Calling place function may lead to "All supplied place locations failed. Retrying last
  // location in
  // verbose mode." This is a known issue and we are working on fixing it. |br|
  // Create a vector of placings to be attempted, currently only creating single place location.
  std::vector<moveit_msgs::PlaceLocation> place_location;
  place_location.resize(1);

  // Setting place location pose
  // +++++++++++++++++++++++++++
  place_location[0].place_pose.header.frame_id = _ref_frame;
  tf2::Quaternion orientation;
  orientation.setRPY(0, 0, M_PI / 2);
  place_location[0].place_pose.pose.orientation = tf2::toMsg(orientation);

  /* While placing it is the exact location of the center of the object. */
  place_location[0].place_pose.pose.position.x = 0;
  place_location[0].place_pose.pose.position.y = 0.5;
  place_location[0].place_pose.pose.position.z = 0.5;

  // Setting pre-place approach
  // ++++++++++++++++++++++++++
  /* Defined with respect to frame_id */
  place_location[0].pre_place_approach.direction.header.frame_id = _ref_frame;
  /* Direction is set as negative z axis */
  place_location[0].pre_place_approach.direction.vector.z = -1.0;
  place_location[0].pre_place_approach.min_distance = 0.095;
  place_location[0].pre_place_approach.desired_distance = 0.115;

  // Setting post-grasp retreat
  // ++++++++++++++++++++++++++
  /* Defined with respect to frame_id */
  place_location[0].post_place_retreat.direction.header.frame_id = _ref_frame;
  /* Direction is set as negative y axis */
  place_location[0].post_place_retreat.direction.vector.y = -1.0;
  place_location[0].post_place_retreat.min_distance = 0.1;
  place_location[0].post_place_retreat.desired_distance = 0.25;

  // Setting posture of eef after placing object
  // +++++++++++++++++++++++++++++++++++++++++++
  /* Similar to the pick case */
  openGripper(place_location[0].post_place_posture);

  // Set support surface as table2.
  _moveGroup.setSupportSurfaceName("table2");
  // Call place to place the object using the place locations given.
  return bool(_moveGroup.place("object", place_location));
  // END_SUB_TUTORIAL
}

bool ArmInterface::addCollisionObjects()
{
  // BEGIN_SUB_TUTORIAL table1
  //
  // Creating Environment
  // ^^^^^^^^^^^^^^^^^^^^
  // Create vector to hold 3 collision objects.
  std::vector<moveit_msgs::CollisionObject> collision_objects;
  collision_objects.resize(3);

  // Add the first table where the cube will originally be kept.
  collision_objects[0].id = "table1";
  collision_objects[0].header.frame_id = _ref_frame;

  /* Define the primitive and its dimensions. */
  collision_objects[0].primitives.resize(1);
  collision_objects[0].primitives[0].type = collision_objects[0].primitives[0].BOX;
  collision_objects[0].primitives[0].dimensions.resize(3);
  collision_objects[0].primitives[0].dimensions[0] = 0.2;
  collision_objects[0].primitives[0].dimensions[1] = 0.4;
  collision_objects[0].primitives[0].dimensions[2] = 0.4;

  /* Define the pose of the table. */
  collision_objects[0].primitive_poses.resize(1);
  collision_objects[0].primitive_poses[0].position.x = 0.5;
  collision_objects[0].primitive_poses[0].position.y = 0;
  collision_objects[0].primitive_poses[0].position.z = 0.2;
  // END_SUB_TUTORIAL

  collision_objects[0].operation = collision_objects[0].ADD;

  // BEGIN_SUB_TUTORIAL table2
  // Add the second table where we will be placing the cube.
  collision_objects[1].id = "table2";
  collision_objects[1].header.frame_id = _ref_frame;

  /* Define the primitive and its dimensions. */
  collision_objects[1].primitives.resize(1);
  collision_objects[1].primitives[0].type = collision_objects[1].primitives[0].BOX;
  collision_objects[1].primitives[0].dimensions.resize(3);
  collision_objects[1].primitives[0].dimensions[0] = 0.4;
  collision_objects[1].primitives[0].dimensions[1] = 0.2;
  collision_objects[1].primitives[0].dimensions[2] = 0.4;

  /* Define the pose of the table. */
  collision_objects[1].primitive_poses.resize(1);
  collision_objects[1].primitive_poses[0].position.x = 0;
  collision_objects[1].primitive_poses[0].position.y = 0.5;
  collision_objects[1].primitive_poses[0].position.z = 0.2;
  // END_SUB_TUTORIAL

  collision_objects[1].operation = collision_objects[1].ADD;

  // BEGIN_SUB_TUTORIAL object
  // Define the object that we will be manipulating
  collision_objects[2].header.frame_id = _ref_frame;
  collision_objects[2].id = "object";

  /* Define the primitive and its dimensions. */
  collision_objects[2].primitives.resize(1);
  collision_objects[2].primitives[0].type = collision_objects[1].primitives[0].BOX;
  collision_objects[2].primitives[0].dimensions.resize(3);
  collision_objects[2].primitives[0].dimensions[0] = 0.02;
  collision_objects[2].primitives[0].dimensions[1] = 0.02;
  collision_objects[2].primitives[0].dimensions[2] = 0.2;

  /* Define the pose of the object. */
  collision_objects[2].primitive_poses.resize(1);
  collision_objects[2].primitive_poses[0].position.x = 0.5;
  collision_objects[2].primitive_poses[0].position.y = 0;
  collision_objects[2].primitive_poses[0].position.z = 0.5;
  // END_SUB_TUTORIAL

  collision_objects[2].operation = collision_objects[2].ADD;

  _planningScene.applyCollisionObjects(collision_objects);
}
